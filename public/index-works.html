<!doctype html>
<html>
    <head>
		<title>Never Ending Stickies</title>
		<style>
			body {
				font-family: 'Lucida Grande', 'Helvetica', sans-serif;
			}

			p.dragnote {
				margin-top: 0;
				color: #666666;
				font-size: 12px;
			}
            #stickyTemplate {
                display: none;
            }
			.note, .edit {
				background-color: rgb(255, 240, 70);
				-webkit-appearance: none;
				-webkit-tap-highlight-color: transparent;
			}
			.note {
				height: 250px;
				padding: 5px;
				position: absolute;
				width: 200px;
				-webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
				-webkit-transform: scale(1.0);
				opacity: 1;
			}

			.note.closed {
				-webkit-transition-property: -webkit-transform, opacity;
				-webkit-transition-duration: 250ms;
				-webkit-transform-origin: top left;
				-webkit-transform: skew(30deg, 0deg) scale(0.01);
				opacity: 0;
			}

			.closeButton {
				display: none;
				background: black;
				height: 30px;
				position: absolute;
				left: -15px;
				top: -15px;
				width: 30px;
				z-index: inherit;
				border-radius: 30px;
				color: white;
				border: solid 2px white;
				box-shadow: 0 5px 10px rgba(0,0,0,.5);
				font-size: 20px;
				line-height: 20px;
				text-align: center;
			}

			.note:hover .closeButton {
				display: block;
			} 

			@-webkit-keyframes pulsing {
				0% { -webkit-transform: scale(1); }
				50% { -webkit-transform: scale(1.05); }
				100% { -webkit-transform: scale(1); }

			}
				
			.note.selected {
				-webkit-animation: pulsing 1.5s infinite ease-in-out;
				-webkit-animation-delay: 0.2s;
			}

			.closeButton:active {
			}

			.edit {
				outline: none;
				border: none;
				font-size: 18px;
				height: 230px;
				width: 195px;
				/*overflow: hidden; let it scroll*/
				resize: none;
				padding-top: 20px;
			}
			.note header {
				display: block;
				position: absolute;
				left: 0px;
				right: 0px;
				top: 0px;
				height: 10px;
				font-size: 9px;
				background-color: #db0;
				color: white;
				padding: 4px 4px;
				text-align: right;
				cursor: move;
				box-shadow: 0 1px 3px rgba(0,0,0,.5);
			}

			.overlay {
				position: absolute;
				height: 100%;
				width: 100%;
				left: 0px;
				top: 0px;
				background-color: Black;
				opacity: 0.0;
				z-index: -1;
				-webkit-transition: opacity 0.2s linear;
			}

			.overlay.shown {
				opacity: 0.5;
				z-index: inherit;
			}
			@media screen and (device-width: 320px), screen and (device-width: 768px) {
				/* content area for each note has to be sized a little differently for iPhone/iPad */
				.edit {
					font-size: 16px;
					height: 230px;
					width: 180px;
				}
				/* close button should always be visible on iPhone/iPad */
				.closeButton {
					display: block;
				}
			}
		</style>
    </head>
    <body>
        <label for="searchField">Find in stickies</label>
        <input type="search" id="searchField">
        <button id="addStickyButton">Add a Sticky</button>
        <p>Drag stickies using the title bar.</p>
        <ul id="breadCrumb">
            <li><a href="#">Top Board</a></li>
        </ul>
		<div class="note" id="stickyTemplate">
			<header></header>
			<textarea class="edit"></textarea>
			<div class="overlay"></div>
			<button class="closeButton">x</button>
			<footer></footer>
		</div>
    </body>
    <script id="lib">
        const NotificationCenter = (()=>{
            let subscribers = {}
            return {
                publish(name, info, publisher){
                    if(!subscribers[name]) return
                    let i = 0
                    const ubounds = subscribers[name].length
                    for(i = 0; i < ubounds; i++){
                        if(subscribers[name][i][name]) subscribers[name][i][name](info, publisher)
                    }
                },
                subscribe(name, subscriber){
                    if(!subscribers[name]) subscribers[name] = []
                    subscribers[name].push(subscriber)
                },
                unsubscribe(name, subscriber){
                    if(!subscribers[name]) return
                    let i = 0
                    const ubounds = subscribers[name].length
                    for(i = 0; i < ubounds; i++){
                        if(subscribers[name][i] === subscriber){
                            subscribers.splice(i, 1)
                            return
                        }
                    }
                }
            }
        })()

        const MakeObservable = obj => {
            let observers = {}
            let self = {
                observe(key, observer){
                    if(!observers[key]) observers[key] = []
                    observers[key].push(observer)
                },
                changed(key, old, value, me){
                    if(!observers[key]) return
                    observers[key].forEach( o => {
                        o.update(key, old, value, me)
                    })
                },
                stopObserving(key, observer){
                    if(!observers[key]) return
                    let index = observers[key].findIndex((o, i) => {
                        return o === observer
                    })
                    if(index === -1) return
                    observers[key].splice(index, 1)
                },
                release(){
                    observers = null
                }
            }
            if(!obj) obj = {}
            let keys = Object.keys(obj)
            let ubounds = keys.length
            for(let i = 0; i < ubounds; i++){
                (() => {
                    let prop = keys[i]
                    Reflect.defineProperty(self, prop, {
                    get(){
                        return obj[prop]
                    },
                    set(v){
                        let old = obj[prop]
                        obj[prop] = v
                        self.changed(prop, old, v, self)
                    },
                    enumerable: true
                    })
                })()
            }
            return self
        }

        const MakeObservableList = list =>{
            let observable = MakeObservable({})
            if(!list) list = []
            let self = {
                push(item){
                    list.push(item)
                    observable.changed("push", null, item, list)
                },  
                list: list,
                pop(){
                    let last = list.pop()
                    observable.changed("pop", last, null)
                    return last
                },
                shift(){
                    let first = list.shift()
                    observable.changed("shift", null, first)
                    return first
                },
                unshift(items){
                    let length = list.unshift(items)
                    observable.changed("unshift", null, items)
                    return length
                },
                last(){
                    if(list.length === 0) return null
                    return list[list.length - 1]
                },
                remove(delegate){
                    let i = 0
                    let ubounds = list.length
                    let deleted = []
                    for(i; i<ubounds;i++){
                        if(delegate(i, list[i])){
                            deleted = list.splice(i, 1)
                            observable.changed("remove", deleted[0], i)
                            break
                        }
                    }
                    return deleted[0]
                },
                removeAll(){
                    let item = null
                    let i = 0
                    while(item = list.pop()){
                        observable.changed("remove", item, i)
                    }
                },
                removeMany(delegate){
                    let ubounds = list.length
                    let i = ubounds-1
                    let deleted = []
                    for(i;i>=0;i--){
                        if(list[i] && delegate(i, list[i])){
                            deleted.push(list.splice(i, 1)[0])
                            observable.changed("remove", deleted[deleted.length-1], i)
                        }
                    }
                    return deleted
                },
                removeUntil(delegate){
                    let ubounds = list.length
                    let i = ubounds-1
                    let deleted = []
                    let limitReached = false
                    for(i;i>=0;i--){
                        limitReached = list[i] && delegate(i, list[i])
                        if(limitReached) break
                        deleted.push(list.splice(i, 1)[0])
                        observable.changed("pop", deleted[deleted.length-1], i)
                    }
                    return deleted
                },
                item(i){
                    return list[i]
                },
                findAll(delegate){
                    let i = 0
                    let ubounds = list.length
                    let found = MakeObservableList([])
                    for(i; i<ubounds;i++){
                        if(delegate(i, list[i])) found.push(list[i])
                    }
                    return found
                },
                find(delegate){
                    let i = 0
                    let ubounds = list.length
                    for(i; i<ubounds;i++){
                        if(delegate(i, list[i])) return list[i]
                    }
                    return null
                },
                some(delegate){
                    return list.some(delegate)
                },
                each(fn){
                    let i = 0
                    let ubounds = list.length
                    for(i; i < ubounds; i++){
                        fn(i, list[i])
                    }
                },
                clear(){
                    while(this.length > 0) this.pop()
                    list = []
                },
                release(){
                    let item = null
                    while(item = list.pop()){}
                    observable.release()
                },
                observe(key, observer){
                    observable.observe(key, observer)
                },
                stopObserving(observer){
                    observable.stopObserving(observer)
                }
            }
            Reflect.defineProperty(self, "length", {
            get(){
                return list.length
            },
            enumerable: true
            })
            return self
        }

        function uuid(){
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
                return v.toString(16);
            });
        }
        
        function require(files){
            var head = document.getElementsByTagName("head")[0];
            var script = null;
            var file = null;
            while(file = files.shift()){
                script = document.createElement("script");
                script.type = "text/javascript";
                script.src = file;
                script.addEventListener("load", function(e){
                    NotificationCenter.publish("script_has_loaded", file, this);
                }, true);
                head.appendChild(script);
            }
        }

        const device = {
            CANTOUCH: ("createTouch" in document),
            MOUSEDOWN: this.CANTOUCH ? "touchstart" : "mousedown",
            MOUSEMOVE: this.CANTOUCH ? "touchmove" : "mousemove",
            MOUSEUP: this.CANTOUCH ? "touchend" : "mouseup",
            CLICK: "click",
            DOUBLECLICK: "dblclick",
            KEYUP: "keyup",
            SEARCH: "search",
            INPUT: "input",
            BLUR: "blur",
            UNLOAD: "unload",
            HASHCHANGE: "hashchange",
        }

        const zeropad = s => {
            const num = parseInt(s)
            if(num<10) return "0" + num
            return "" + num
        }
    </script>
    <script id="app">
        const Repo = (() => {
            function get(){
                if(localStorage.notes === undefined) return null
                var notes = JSON.parse(localStorage.notes)
                if(notes === null) return null
                return notes.map( note => {
                    return new Note(note)
                })
            }
            function set(notes){
                localStorage.clear()
                localStorage.notes = JSON.stringify(notes)
            }
            return {
                save(note){
                    var notes = get()
                    var i = 0
                    var saved = false
                    note.timestamp = new Date()
                    if(notes !== null){
                        var ubounds = notes.length
                        for(i=0;i<ubounds;i++){
                            if(notes[i].id === note.id){
                                notes[i] = note
                                saved = true
                                break
                            }
                        }			
                    } else {
                        notes = []
                    }
                    if(!saved) notes.push(note)
                    set(notes)
                },
                delete(note){
                    var i = 0
                    var notes = get()
                    var ubounds = notes.length
                    var found = []
                    for(i = 0; i < ubounds; i++){
                        if(notes[i].id == note.id){
                            notes.splice(i, 1)
                            break
                        }
                    }
                    set(notes)
                    return i
                },
                all(){
                    return get()
                },
                findOne(delegate){
                    let found = this.find(delegate)
                    if(found !== null) return found[0]
                },
                find(delegate){
                    var notes = get()
                    if(!notes) return []
                    var i = 0
                    var ubounds = notes.length
                    var found = []
                    for(i = 0; i < ubounds; i++){
                        if(delegate(notes[i])) found.push(notes[i])
                    }
                    return found.length > 0 ? found : []
                }
            }
        })()

        class Note {
            constructor(args){
                if(!args){
                    args = {}
                }
                this.id = args.id || uuid()
                if(args && args.timestamp){
                    args.timestamp = new Date(args.timestamp)
                }
                this.timestamp = new Date()
                this.text = args.text || null
                this.top = args.top || 0
                this.left = args.left || 0
                this.z = args.z || 0
                this.parentId = args.parentId || null
                this.notes = MakeObservableList([])
            }
        }

        class BreadCrumb {
            constructor(container, model, delegate){
                this.container = container
                this.model = model
                this.delegate = delegate
                this.model.observe("push", this)
                this.model.observe("unshift", this)
                this.model.observe("remove", this)
                this.model.observe("pop", this)
                this.template = this.container.querySelector("li").cloneNode(true)
                this.container.addEventListener(device.CLICK, e => {
                    if(e.target.tagName !== "A") return
                    let id = e.target.href.split("#")[1]
                    if(id.length === 0) id = null
                    this.delegate.breadCrumbWasClicked(id)
                })
            }
            update(key, old, v, m){
                if(key === "push") this.add(v)
                if(key === "unshift") this.addToFront(v)
                if(key === "remove") this.remove(v)
                if(key === "pop") this.remove(old)
            }
            addToFront(note){
                if(!note) return
                let li = this.template.cloneNode(true)
                li.id = "breadCrumb_" + note.id
                let a = li.querySelector("a")
                a.href = "#" + note.id
                a.title = note.text || "No text"
                a.innerText = note.text ? note.text.substring(0, 20) : "No text"
                if(this.container.querySelector("li").length === 1){
                    this.container.appendChild(li)
                } else {
                    this.container.insertBefore(li, this.container.querySelector("li:first-child").nextSibling)
                }
            }
            add(note){
                if(!note) return
                let li = this.template.cloneNode(true)
                li.id = "breadCrumb_" + note.id
                let a = li.querySelector("a")
                a.href = "#" + note.id
                a.title = note.text || "No text"
                a.innerText = note.text ? note.text.substring(0, 20) : "No text"
                this.container.appendChild(li)
            }
            remove(note){
                if(!note) return
                this.container.removeChild(this.container.querySelector("#breadCrumb_" + note.id))
            }
        }
        class SearchField {
            constructor(container, model, delegate){
                this.container = container
                this.model = model
                this.delegate = delegate
                this.model.observe("findTerm", this)
                this.container.addEventListener(device.INPUT, e => {
                    this.model.findTerm = e.target.value
                })
                this.container.addEventListener(device.SEARCH, e => {
                    console.log("searched for")
                })
                this.container.addEventListener(device.BLUR, e => {
                    if(this.model.findTerm.length === 0) this.stopFinding(this.model.findTerm)
                })
            }
            update(key, old, v, m){
                if(key === "findTerm"){
                    this.startFinding(v)
                }
            }
            startFinding(term){
                let notes = null
                if(term.length > 0){
                    notes = Repo.find(n =>{
                        return n.text.indexOf(term) > -1
                    })
                }
                this.delegate.noteWasFound(notes)
            }
            stopFinding(term){
                this.delegate.doneFinding()
            }
        }

        class Mover {
            constructor(container, model, delegate){
                this.container = container
                this.model = model
                this.delegate = delegate
                this.startX = 0
                this.startY = 0
            }
            handleEvent(e){
                if(e.type === device.MOUSEMOVE){
                    // stop page from panning on iPhone/iPad - we're moving a note, not the page
                    e.preventDefault()
                    e = (device.CANTOUCH && e.touches && e.touches.length > 0) ? e.touches[0] : e
                    this.container.style.left = (e.clientX - this.startX) + "px"
                    this.container.style.top = (e.clientY - this.startY)+ "px"
                    return
                }

                if(e.type === device.MOUSEUP){
                    this.model.top = parseInt(this.container.style.top.replace("px", ""))
                    this.model.left = parseInt(this.container.style.left.replace("px", ""))
                    this.model.z = this.container.style.zIndex
                    window.removeEventListener(device.MOUSEMOVE, this, true)
                    window.removeEventListener(device.MOUSEUP, this, true)
                    this.delegate.dropped(this)
                    return
                }
                
                if(e.type === device.MOUSEDOWN){
                    this.dragStart(e)
                    return
                }
            }
            dragStart(e){
                e.preventDefault()
                this.delegate.makeActive()
                e = (device.CANTOUCH && e.touches && e.touches.length > 0) ? e.touches[0] : e
                this.startX = e.clientX - this.container.offsetLeft
                this.startY = e.clientY - this.container.offsetTop
                window.addEventListener(device.MOUSEMOVE, this, true)
                window.addEventListener(device.MOUSEUP, this, true)
            }
        }
        class Sticky {
            constructor(container, model, delegate){
                this.model = model
                this.container = container
                this.delegate = delegate
                this.container.id = this.model.id
                this.mover = new Mover(this.container, this.model, this)
                this.closeButton = this.container.querySelector(".closeButton")
                this.overlay = this.container.querySelector(".overlay")
                this.closeButton.addEventListener(device.CLICK, e => {
                    this.close(e)
                }, {once: true}, true)
                this.header = this.container.querySelector("header")
                this.textarea = this.container.querySelector("textarea")
                this.textarea.addEventListener(device.KEYUP, e => {
                    this.model.text = e.target.value
                    this.save()
                }, false)
                this.header.addEventListener(device.DOUBLECLICK, e => {
                    this.delegate.diveIn(this)
                }, {once: true}, true)
                this.header.addEventListener(device.MOUSEDOWN, e => {
                    this.mover.dragStart(e)
                }, false)
                this.container.addEventListener(device.CLICK, e => {
                    this.delegate.makeActive(this)
                }, true)
                this.textarea.value = this.model.text
                this.container.style.top = this.model.top + "px"
                this.container.style.left = this.model.left + "px"
                this.container.style.zIndex = this.model.z
            }
            update(key, old, v, m){

            }
            release(){

            }
            close(e){
                this.release()
                this.delegate.remove(this)
            }
            makeActive(){
                this.delegate.makeActive(this)
            }
            dropped(){
                this.delegate.dropped(this)
            }
            save(){
                this.delegate.save(this)
            }
        }
        const iterate = note => {
            if(note.parentId){
                return Repo.all().find(n=>n.id === note.parentId)
            } else {
                return null
            }
        }

        let app = {
            open(win){
                this.win = win
                this.doc = this.win.document
                this.model = MakeObservable({
                    notes: MakeObservableList([]),
                    parentId: null,
                    breadCrumbs: MakeObservableList([]),
                    findTerm: ""
                })
                this.views = []
                this.model.notes.observe("push", this)
                this.model.notes.observe("remove", this)
                this.model.notes.observe("pop", this)
                this.doc.getElementById("addStickyButton").addEventListener(device.CLICK, e => {
                    this.model.notes.push(MakeObservable(new Note()))
                })
                this.stickyTemplate = this.doc.getElementById("stickyTemplate").cloneNode(true)
                this.stickyTemplate.id = ""
                this.breadCrumb = new BreadCrumb(this.doc.getElementById("breadCrumb"), this.model.breadCrumbs, this)
                this.searchField = new SearchField(this.doc.getElementById("searchField"), this.model, this)
                this.model.observe("parentId", this)
                if(this.win.location.hash){
                    this.model.parentId = this.win.location.hash.replace("#", "")
                }
                let notes = Repo.all()
                if(notes && this.model.parentId){
                    notes = notes.filter(n=>n.parentId === this.model.parentId)
                    let parent = Repo.findOne(n=>n.id === this.model.parentId)
                    this.firstLoadBreadCrumbs(parent)
                }
                this.firstLoad(notes)
            },
            firstLoadBreadCrumbs(crumb){
                if(crumb){
                    this.model.breadCrumbs.unshift(MakeObservable(crumb))
                    let parent = Repo.findOne(n=>n.id === crumb.parentId)
                    this.firstLoadBreadCrumbs(parent)
                }
            },
            firstLoad(notes){
                if(notes && !this.model.parentId){
                    notes = notes.filter(n=>!n.parentId)
                    notes.forEach(n=>{
                        this.model.notes.push(MakeObservable(n))
                    })
                }
            },
            update(key, old, v, m){
                if(key === "parentId") {
                    this.win.location.hash = v
                    this.clearBoard(v)
                    this.reloadBoard(v)
                }

                if(key === "push"){
                    this.addSticky(v)
                }
                if(key === "remove"){
                    this.removeSticky(old)
                }
            },
            removeBreadCrumbsTo(parentId){
                for(let i = this.model.breadCrumbs.length - 1; i>= 0; i--){
                    if(this.model.breadCrumbs.item(i).id === parentId){
                        break
                    }
                    this.model.breadCrumbs.pop()
                }
            },
            reloadBoard(parentId){
                let notes = Repo.all()
                if(!notes) notes = []
                if(parentId){
                    notes = notes.filter(n=>n.parentId === parentId || n.id === parentId)
                } else {
                    notes = notes.filter(n => !n.parentId)
                }
                notes.forEach(n=>{
                    this.model.notes.push(MakeObservable(n))
                })
            },
            clearBoard(parentId){
                this.model.notes.removeAll()
            },
            removeSticky(note){
                let index = this.views.findIndex(v => v.model.id === note.id)
                this.views.splice(index, 1)
                this.doc.body.removeChild(this.doc.getElementById(note.id))
            },
            removeFromRepo(note){
                if(note){
                    Repo.delete(note)
                    Repo.find(n=>n.parentId === note.id)
                        .forEach(n=>{
                            this.removeFromRepo(n)
                        })
                }
            },
            addSticky(note){
                let container = this.stickyTemplate.cloneNode(true)
                container.id = note.id
                if(this.model.parentId && note.id !== this.model.parentId) note.parentId = this.model.parentId
                this.views.push(new Sticky(container, note, this))
                this.doc.body.appendChild(container)
            },
            breadCrumbWasClicked(id){
                this.model.parentId = id
                this.removeBreadCrumbsTo(id)
            },
            makeActive(sticky){
                this.views.forEach( v =>{
                    v.container.style.zIndex = 0
                })
                sticky.container.style.zIndex = 1
            },
            dropped(sticky){
                Repo.save(sticky.model)
            },
            diveIn(sticky){
                if(sticky.model.id === this.model.parentId) return
                this.model.parentId = sticky.model.id
                this.model.breadCrumbs.push(sticky.model)
                this.clearBoard(sticky.model.id)
                this.model.notes.push(sticky.model)
                let notes = Repo.all().filter(n=>n.parentId === sticky.model.id)
                notes.forEach(n=>{
                    this.model.notes.push(MakeObservable(n))
                })
            },
            remove(sticky){
                this.model.notes.removeMany((i, n)=>{
                    return n.parentId === sticky.model.id || n.id === sticky.model.id
                })
                if(this.model.breadCrumbs.some(c=>c.id === sticky.model.id)){
                    this.removeBreadCrumbsTo(sticky.model.id)
                    if(this.model.breadCrumbs.last().id === sticky.model.id){
                        this.model.breadCrumbs.pop()
                    }
                    this.model.parentId = this.model.breadCrumbs.last().id
                }
                this.model.notes.remove((i, n)=>{
                    return n.id === sticky.model.id
                })
                this.removeFromRepo(sticky.model)
            },
            save(sticky){
                Repo.save(sticky.model)
            },
            noteWasFound(notes){
                this.views.forEach(v => {
                    v.overlay.className = "overlay shown"
                    v.container.className = "note"
                })
                if(!notes) return
                notes.forEach(n => {
                    let sticky = this.views.find(v => v.model.id === n.id)
                    if(sticky){
                        sticky.overlay.className = "overlay"
                        sticky.container.className = "note selected"
                    }
                })
            },
            doneFinding(){
                this.views.forEach(v => {
                    v.overlay.className = "overlay"
                    v.container.className = "note"
                })
            }
        }
        app.open(window)
    </script>
</html>